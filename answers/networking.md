# Topic: NETWORKING

## How TCP open a connection? What does it need to open a connection?

TCP (Transmission Control Protocol) is one of the main protocols in the Internet Protocol (IP) suite, and it provides reliable, connection-oriented communication between devices on a network. To open a connection, TCP uses a process known as the three-way handshake:

1. **SYN (Synchronize)**
   - The process begins with the client sending a TCP packet with the SYN flag set to the server. This packet contains an initial sequence number (ISN) generated by the client.
   - The client is essentially saying, "I want to establish a connection with you, and here is my initial sequence number."

2. **SYN-ACK (Synchronize - Acknowledge)**
   - Upon receiving the SYN packet, if the server is willing to establish a connection, it responds with a packet that has both the SYN and ACK flags set.
   - The server also generates its own initial sequence number (ISN) and includes it in the packet.
   - The server is essentially saying, "I acknowledge your request to connect, and I also want to establish a connection with you. Here's my initial sequence number."

3. **ACK (Acknowledge)**
   - Finally, the client acknowledges the server's response by sending a packet with the ACK flag set.
   - This packet also contains an acknowledgment number, which is the server's initial sequence number incremented by 1.
   - The client is essentially saying, "I acknowledge your acknowledgment. Let's start communicating."

At this point, the connection is established, and both parties can start sending data to each other reliably.

In addition to the three-way handshake, there are several other aspects that TCP needs to open a connection:

1. **IP Addresses**: Each device on a network has a unique IP address. This is crucial for routing packets between devices.

2. **Port Numbers**: Along with the IP address, a port number is used to identify specific services or processes on a device. For example, HTTP typically uses port 80, while HTTPS uses port 443.

3. **Socket**: A socket is a combination of an IP address and a port number. Together, they uniquely identify a specific endpoint on a network.

4. **Buffering and Flow Control**: TCP provides mechanisms for managing the flow of data between sender and receiver, ensuring that data isn't sent too fast for the recipient to handle.

5. **Error Detection and Correction**: TCP includes mechanisms for detecting and correcting errors in data transmission to ensure the integrity of the communication.

These elements work together to enable TCP to establish reliable connections between devices on a network, allowing for the transmission of data in a way that ensures it arrives intact and in the correct order.

## Why there are 3 way handshakes but not 2 way?

The three-way handshake is used in TCP for several important reasons, which a two-way handshake wouldn't adequately address:

1. **Initiator and Responder Identification**: In a two-way handshake, if the server simply acknowledged the client's request to connect, there would be no way for the server to communicate its own intent to establish a connection. The three-way handshake allows both parties to express their willingness to establish a connection.

2. **Synchronization of Sequence Numbers**: The initial sequence numbers (ISNs) exchanged during the handshake are crucial for maintaining the order of data segments in the communication. In a two-way handshake, if the server were to respond with just an acknowledgment, it would have no way to communicate its own ISN to the client. This could lead to problems with sequence number synchronization.

3. **Prevents Half-Open Connections**: A two-way handshake could potentially lead to a situation known as a "half-open connection." This occurs when one party believes a connection is established, but the other does not. The third step of the three-way handshake helps prevent this scenario by confirming the connection on both sides.

4. **Security**: The three-way handshake introduces an additional step that helps protect against certain types of attacks, like SYN flood attacks. These attacks involve sending a large number of SYN packets without completing the handshake, potentially overwhelming a server's resources. The three-way handshake ensures that both parties are invested in the connection.

5. **Completeness of Communication**: Each step in the three-way handshake serves a specific purpose: initiation, acknowledgment, and confirmation. These steps work together to establish a full, mutual agreement to initiate a connection.

Overall, the three-way handshake is a well-designed mechanism that helps ensure reliable and secure communication in TCP. It's a fundamental part of how TCP operates, and it provides benefits that a two-way handshake wouldn't be able to offer.

## What is syn, ack mean?

Syn means synchronizaton. SYN packet is sent when the sender tries to connect to the receiver.

Ack means acknowledgment. ACK packet is sent by the receiver to the sender to help the sender know that the SYN packet that it sent before reached the destination successfully.

## Why they have to send 2 "random" sequence numbers? The purpose of this sequence number?

Sequence numbers are used to keep track of the order of data. The initial sequence number needs to be chosen randomly so the data in one flow will not be conflicted with other data bytes in other flows which are transmitted in the same TCP connection. Because sequence number is 32-bit integer so the maximum value of a sequence number is 2^32 - 1. So if the amount of data is greater than 4GB, at least one sequence number value will be reused.

## What if the 3rd handshake fail? How the server can detect it and what does it do in this case?

If the third handshake (the ACK from the client) were to fail, it would indicate that the client did not receive the acknowledgment from the server. This could happen due to a variety of reasons, such as network congestion, a misconfigured firewall, or a temporary network issue.

Here's what would typically happen if the third handshake fails:

1. **Timeout and Retransmission**:
   - After a certain period of time without receiving the expected ACK, the client will assume that the acknowledgment was lost in transit and will retransmit the SYN packet.
   - The server, upon receiving this retransmitted SYN packet, will again respond with a SYN-ACK.

2. **Connection Establishment Attempt (Retry)**:
   - The client will continue attempting to establish the connection by sending the SYN packet.
   - The server will respond with SYN-ACK as long as it is still willing to establish the connection.

3. **Connection Termination** (Eventually):
   - If the server decides to give up on establishing the connection (perhaps due to a timeout on its end), it will not respond to subsequent SYN packets from the client. This would effectively signal the client that the connection could not be established.

It's important to note that TCP is designed to be robust and to handle scenarios where packets are lost or delayed. This is why it includes mechanisms for retransmission of data and acknowledgment of received data.

In practice, if the third handshake consistently fails, it might indicate a more serious issue, such as a network misconfiguration or a problem with one of the systems involved. Troubleshooting such issues would involve examining network configurations, firewall settings, and potentially conducting network diagnostics to identify and rectify the underlying problem.

## How TCP handles the connection?

TCP (Transmission Control Protocol) handles connections in a reliable and connection-oriented manner. Here's a brief overview of how TCP manages connections:

1. **Connection Establishment**:
   - As discussed earlier, TCP uses a three-way handshake to establish a connection between a client and a server. This involves the exchange of SYN (synchronize) and ACK (acknowledge) packets to confirm both parties' intent to establish a connection.

2. **Data Transmission**:
   - Once a connection is established, data can be transmitted in both directions (from the client to the server and vice versa).
   - TCP segments the data into manageable chunks called segments and adds sequence numbers to them.

3. **Acknowledgment and Flow Control**:
   - After receiving a segment, the receiver sends back an acknowledgment (ACK) to confirm receipt of the data. The ACK includes the next expected sequence number.
   - TCP also implements flow control mechanisms to prevent overwhelming the receiver with data. The receiver advertises its receive window size, indicating how much data it can currently accept.

4. **Retransmission**:
   - If a segment is not acknowledged within a certain timeout period, the sender assumes it was lost in transit and retransmits it. This ensures reliable data delivery.

5. **Out-of-Order Data Handling**:
   - TCP is designed to handle out-of-order delivery of segments. Each segment has a sequence number, allowing the receiver to correctly order the data upon receipt.

6. **Congestion Control**:
   - TCP monitors network conditions to avoid congestion. It adapts its transmission rate based on the available bandwidth and network congestion signals.

7. **Connection Termination**:
   - When the communication is complete, a four-way handshake is used to terminate the connection. This involves sending FIN (finish) and ACK packets to signal the intent to close the connection.

8. **TIME_WAIT State**:
   - After a connection is closed, TCP enters a TIME_WAIT state to ensure that any delayed packets related to the closed connection are handled properly. This prevents confusion with new connections using the same port numbers.

9. **Connection State Management**:
   - Throughout the connection, TCP maintains a state for each connection. This includes information about sequence numbers, window sizes, and other parameters.

10. **Error Detection and Correction**:
    - TCP uses checksums to verify the integrity of data segments. If a segment is received with a checksum error, it is discarded, and the receiver may request retransmission.

By incorporating these features, TCP ensures reliable, ordered, and flow-controlled data delivery over IP networks, making it a fundamental protocol for many applications on the internet.

## What happens if some bits are wrong due to connection errors? How to detect them and fix them?

TCP uses a few mechanisms to detect and handle errors caused by incorrect or corrupted bits during data transmission:

1. **Checksums**:
   - TCP employs a checksum algorithm to detect errors in the received data. When a segment is received, the receiver calculates the checksum based on the received bits and compares it to the checksum value included in the segment's header.
   - If the calculated checksum does not match the received checksum, the segment is considered corrupt, and it is discarded. The receiver may request the sender to retransmit the corrupted segment.

2. **Retransmission**:
   - If a segment is not acknowledged within a certain timeout period, or if it's determined to be corrupt due to a checksum mismatch, the sender will retransmit the segment. This ensures that data is reliably delivered, even in the presence of errors.

3. **Sequence Numbers**:
   - TCP uses sequence numbers to ensure that data segments are delivered in the correct order. If a segment arrives out of order, the receiver will hold it until the missing segments are received, preventing incorrect data from being delivered.

4. **Selective Acknowledgment (SACK)**:
   - In some cases, TCP implementations may use a SACK option to allow the receiver to specify which segments were received successfully and which were not. This provides more granular feedback to the sender, enabling it to retransmit only the necessary segments.

5. **Flow Control**:
   - TCP's flow control mechanisms prevent the sender from overwhelming the receiver with data. The receiver advertises a window size, indicating how much data it can currently accept. This helps prevent congestion and reduces the likelihood of errors.

6. **Error Detection and Correction Codes (ECC)**:
   - In some cases, particularly in high-reliability environments, additional error detection and correction codes may be applied at the hardware level. These codes can detect and correct certain types of errors.

7. **Automatic Repeat reQuest (ARQ)**:
   - Some lower-level protocols (e.g., at the link layer) may implement ARQ techniques. ARQ involves automatic retransmission of packets when errors are detected.

It's important to note that while TCP provides reliable data transmission, it's not foolproof. There are rare situations where errors may occur despite these mechanisms. For instance, if a segment is corrupted in a way that the checksum still matches (a very unlikely event), the error might not be detected. In such cases, higher-level protocols or applications may need to implement their own error-checking mechanisms.

## How the timeout is handled? what if the timeout is expired?

The timeout in TCP is a crucial aspect of ensuring reliable communication. It's used to handle situations where an acknowledgment (ACK) is not received within a reasonable amount of time. Here's how it works:

1. **Sending Data**:
   - When a sender transmits a TCP segment, it starts a timer associated with that segment. This timer is set based on the expected round-trip time (RTT) for the network.

2. **Expecting an Acknowledgment**:
   - The sender expects to receive an acknowledgment (ACK) from the receiver within the timeout period. The ACK confirms that the receiver has successfully received the data.

3. **Timeout Expiry**:
   - If the timer expires before the acknowledgment is received, it indicates that the ACK was lost in transit or the receiver did not receive the segment.
  
4. **Retransmission**:
   - Upon timeout, the sender assumes the segment was lost and retransmits it. This is a crucial part of TCP's reliability. It ensures that data is delivered even if an acknowledgment is not received.

5. **Adaptive Retransmission**:
   - TCP uses various algorithms to dynamically adjust the timeout value based on network conditions. For example, if the sender consistently receives acknowledgments quickly, it may decrease the timeout to expedite retransmissions. Conversely, if acknowledgments are consistently delayed, it may increase the timeout to allow for longer network delays.

6. **Backoff Strategies**:
   - TCP also employs backoff strategies to prevent congestion in case of continuous retransmissions. For example, the sender might double the timeout value after each unsuccessful attempt.

7. **Fast Retransmit and Fast Recovery**:
   - TCP includes mechanisms for detecting and recovering from packet loss more quickly than waiting for a timeout. This is known as Fast Retransmit and Fast Recovery. If a sender receives duplicate acknowledgments, it assumes a segment was lost and retransmits it without waiting for a timeout.

8. **Congestion Control**:
   - TCP also considers timeouts as a potential sign of network congestion. If timeouts occur too frequently, it may adjust its transmission rate to alleviate congestion.

If a timeout occurs and retransmissions do not result in successful delivery, the sender and receiver may continue to attempt communication. However, if the connection remains unresponsive for an extended period, the application or higher-level protocol may need to handle the situation (e.g., by closing the connection or alerting the user).

## What will happen if some "packet" is missing on the way?

When a packet is missing, network congestion is assumed to happen. TCP has its own way to deal with network congestion. It is called TCP Congestion control. It starts when slow-start phrase, in which the transmit rate (congestion window) grows exponentially, doubling each round trip time. When a packet is lost, congestion avoidance begins. The transmit rate is cut into half, then increase linearly, usually by 1 each RTT.

## How to detect the appropriate number of packets to send (speed of sending packet)?

Like above.

## How TCP close the connection?

It does a 4-way handshake. Firstly peer A send a FIN packet to peer B. Then peer B send an ACK packet for the FIN it receives. After that peer B send it own FIN packet to peer A. Then peer A send ACK packet to the peer B. Connection is over.
Step 2 and 3 can be merged by one, so it will be 3-way handshake instead.

## What if the internet is dropped in the middle of the connection? Or in case one peer is crash?

To be defined

## How long you can keep a TCP connection alive?

To be defined

## What are the differences between TCP and UDP? And in which case we use which?

The key difference between TCP and UDP is TCP has a mechanism to resend loss packets, but UDP doesn't. So TCP suits in the case where packet loss can not be acceptable, like transfer file, request... UDP suits in the case packet loss can be tolerated, like in real-time voice/video calls.

## How Ping command works? What is TTL? How does TTL will be changed?

Ping command sends a packet to the destination server, waits for the response then calculates round trip time.

Time-to-live is a mechanism that prevents a packet to be forward around the internet forever. Like the name, it is the number of times or hops, that packet can be forward before it is discarded by a router. Each time a router receives a packet, it reduces TTL of that packet by 1. If TTL reaches zero, the router will discard this packet then send an ICMP message back to the sender. The recommended default value of TTL is 64.

## How HTTP works?

HTTP is an application protocol that transfers hypertext messages between client and server. It uses specific request methods to perform specific tasks. They include:

- POST: create a new entity
- PUT: update an entity entirely
- PATCH: update an entity partially
- GET: get value
- HEAD: get value without data
- OPTION: get all the methods that the server supports for this resource
- ...

## Why did people say that HTTP is stateless? The reason they make it stateless?

People say HTTP is stateless because each request is executed independently. Stateless provides high scalability.

## Can we make a persistent HTTP connection? pros and cons of this way?

Yes.
HTTP persistent connection keeps one connection to send many objects. It can help reduce CPU resources, travel time, network traffic... But resources will be occupied and not be available to others.

## Why HTTP require cookie each time we send the request?

No it doesn't required cookie.

## Can someone use your cookie and log in your Facebook account? How to migrate this?

If Facebook stores authentication straight info in cookies normally and does not do anything special, the answer is yes.
We can mitigate it using HttpOnly flag.

## What is HTTP session? How does authentication work in HTTP? What is JWT?

Cause HTTP is stateless, HTTP session and cookie are two ways to connect some requests together.

Session is created and stored at server side, usually just temporary. Session ID will be sent to client, client may submit it to server as a cookie, or url parameter, so server will know which session this request belongs to. Session ends when user logout, close web browser, or timeout. Session is more secure, compared to cookie.

Cookie is stored at client browser. Cookie will expire at the set time.

JWT is standard for creating data with opt-in signature and encryption, used for authentication.

## Which type of "data" HTTP can help us to get or push? (binary file? image? text file? video file? music file?)

HTTP can help us get or push all kinds of files like text, image, binary, video, music...

## REST/RESTful?

REST stands for representational state transfer. It's a set of constraints that describes how an API should work. It includes four main principles:

- Client-Sever: There is always a client and a server. Client sends request to server and server reply with response.
- Stateless: Server handles client request independently. Client's request must contain enough information that server requires.
- Uniform interface: For example, a resource is identified in URI, HTTP response always comes with status and body.
- Cacheability: Client can cache response.

An API that follows REST constraints is called RESTful.

## AJAX technique?

AJAX uses XMLHttpRequest to communicate with server. The first "A" stands for asynchronous, which means using AJAX, we can communicate with server without reloading the page.

## How HTTPS work?

HTTPS uses SSL - Secure Socket Layer to protect the communication by encryption. Before exchanging data, an SSL connection must be established first, then data will be encrypted then transferred safely.

## Learn about some useful headers

To be defined.

## When you type "google.com" into your browser, that will happen when you type enter till everything is displayed on your screen?

The first thing that happens is DNS lookup. The browser will get the corresponding IP address with the domain name from its cache, from the computer cache, from the local host file. If there is no data in these places, then the browser will send a request to DNS server to obtain the IP address. ([More](https://serverfault.com/questions/208172/how-does-my-browser-know-where-to-get-data-from-a-server))

The second thing is browser will detect if HTTPS is required or not in case we don't type the full url. Browser can get this information from its history data, from a preload list. Otherwise, it will send an HTTP request. (When server receives the request, server can do appropriate action to force user uses HTTPS if it wants.)

The third thing is TCP connection establishment. The TCP connection can be established by a process called 3-way handshake. If HTTPS is used, after TCP connection is established, the SSL connection establishment process will start.

Fourthly, after having the connection, client will send data to the server and server will send a response back to client through this connection.

The next thing is browser will render the data from response based on the content type. If there is no content type, the broswer will read the body of response to know which kind of data it is. If the content type is html, broswer will parse it then get resources like images, js files, css files if necessary.

## DNS lookup (in case you already access google.com before and also in case you do not know the IP of google.com)

DNS information is cached in browser and operating system. If there is no corresponding data in both of these places, DNS request will be sent to the DNS resolver. The resolver will make necessary request to Top Level Domain server, to Domain Name server to get the IP address of the requested host, then return to user.

## Which protocol DNS use and why?

DNS primarily uses UDP as transport protocol because it's fast and DNS data usually is small and fits an UDP packet.

TCP is used when the data is greater than 512 bytes, which can not be fit on a single UDP packet.

## The other of place to look up DNS.

To be defined.

## TCP or UDP will be used in this case? why?

To be defined.

## How to know "google.com" require HTTP or HTTPS? how browser can know and redirect from HTTP to HTTPS?

There are at least two ways that make the web we are accessing change from using HTTP to HTTPS.

The first way is the server will redirect to HTTPS when the HTTP request comes.

The second way is using HSTS, HTTP strict transport security. When a browser sends the first HTTP request to server, server will add a header into the response indicates that the next request will require using HTTPS. Browser will automatically use HTTPS next time based on that information. In addition, browsers like Chrome have a HSTS preload list, they will automatically use HTTPS for all of the sites in that list.

## After you get the HTML content for "google.com" how to get the \*.js and image files?

Chain requests.

## When getting \*.js or image files do why use another TCP connection or use the same one as in the get HTML content? How DNS lookup work in this case?

To be defined.

## After your browser display "google.com" fully, is there any connection open?

It depends on if the connection is keep alive or not.

## Caching can apply to which steps? How caching applied?

To be defined.

## What is the connection pool? It's advantages and disadvantages? How to implement connection pool in your programing language?

Connection pool is a cache of database connections so connection can be reused when future request comes. Opening a connection is costly, so after a connection is opened, it is placed into connection pool so it can be reused later.

## What is socket?

Socket is an endpoint for a program to send and receive data across the network. Socket allows communication between processes on the same machine or different machines.

## Why do we need socket? Why socket is a "file" in linux?

Not only socket, everything is treated as files in Linux operating system. It provides a common and universal interface for things to communicate in this OS.

## What is src port when you create a connection to a "server"?

To be defined.

## How one server can handle multiple connections to the same port?

As below.

## What is the maximum number of connections a server can handle? (if it has unlimited resource) (in case of the same client and in case of multiple clients)

TCP has 4 fields to identify the uniqueness of a socket: source IP, source port, destination IP, destination port.
Theoretically, if server listens on a port, a client can open a maximum of 2^16 connection. that's is the maximum number of ports a client can open. For multiple clients, the number can be multiplied by 2^32, it is the possible number of source IP addresses. So the maximum number of connections is 2^48.

But in practice, the maximum number of connections depends on the kernel configuration. Because each socket needs a file descriptor, the number of sockets is limited by the maximum number of file descriptors that the machine allows. In addition, a file descriptor needs a certain amount of memory so it can also be limited by the number of available memory.

## When you open multiple tabs on your chrome, how OS knows which packet (both sending and receiving) correspond to which tab? (how about in se you open many tabs to the same page "for eg: google.com")

Because each connection has its own socket that is used to exchange data.

## What are the maximum numbers of connection your machine can connect to "google.com" (if you have unlimited resource)

It is the maximum number of ports my machine can open, which is 2^16.

## Can two processes listen to the same port on your machine? Why? How?

Yes, and it is useful for multicast purpose. Socket needs to be specified as a reused socket before binding to do so.

## What is buffer? why we always need buffer when working with "file"?

Buffer is a segment of memory that is reserved to store necessary data being processed. Buffer helps reduce the processing time.

## What is unix socket? When to use it?

Unix socket or IPC socket is a data communication endpoint that allows processes in a same machine to communicate with others.

## What is TCP proxy? reverse proxy? and VPN?

A TCP proxy server is a server that acts as an intermediary between and client and server. Its goal is to hide clients on the internet. The server only knows that request came from the proxy server and doesn't know about the actual clients.

A reverse proxy, on the other hand, protect server from client. It hides server from client. from the client point of view, client sends data to the reverse proxy and receives data from it too.

VPN allows devices on a public network to be connected as they are in a private network.

## How your router at your home works?

Router connects devices within a network by forwarding packets between them. Packets might be sent between devices, or from a device to the internet and vice versa. It maintains an ARP (address resolution protocol) table to know where to forward a packet to.

## Inside LAN network, it uses IP or MAC address? Why?

Inside a LAN network, it uses MAC address cause we don't need a layer 3 protocol to communicate between devices that are in the same local network.

## How does it know which packet comes from (or arrive at) which machine?

Router will use the ARP table to know the MAC address of the device which this packet is sent to.

## What is the difference between Hub and Switch inside LAN?

Hub is operated on Physical layer and supports only broadcast transmission.

Switch is operated on Data link layer and supports unicast, multicast, and broadcast transmission.s

## How src IP/PORT and dst IP/PORT change on the way to the server?

To be defined.

## How load balancer works?

Load-balancer distributes load to servers. It can do it randomly, uses an algorithm like round-robin, or distribute requests based on the current load of each server.

## When we send a packet to a load balancer how does it forward to the desired server? (Does it keep any data on its memory?)

As above (No).

## When the server wants to send data back to the client, does the connection need to go through the load balancer?

It depends on whether the server and the load balancer are in the same private network and share the same IP address.

## What is different between reverse proxy and load balancer?

Reserve proxy acts as an intermediary without any load distributing operation.

## Can load balancer be a bottleneck? (Because it is the end point of too many requests) (bottleneck about RAM or CPU or Network?)

Yes. And it also can be a single point of failure.
